<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pronunciation Practice</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      margin: 0;
      min-height: 100vh;
      transition: background 0.3s, color 0.3s;
    }
    body.dark {
      background: #121212;
      color: #e0e0e0;
    }
    h1 { color: #333; margin-bottom: 1rem; }
    body.dark h1 { color: #e0e0e0; }
    .input {
      width: 100%;
      max-width: 32rem;
      padding: 0.625rem;
      font-size: 1rem;
      margin-bottom: 0.625rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      box-sizing: border-box;
      transition: border-color 0.3s;
    }
    body.dark .input {
      background: #1e1e1e;
      color: #e0e0e0;
      border-color: #444;
    }
    textarea.input { height: 7.5rem; resize: vertical; position: relative; }
    textarea::after {
      content: attr(data-count);
      position: absolute;
      bottom: 0.5rem;
      right: 0.5rem;
      font-size: 0.8rem;
      color: #666;
    }
    body.dark textarea::after { color: #aaa; }
    textarea.recording {
      border-color: #dc3545;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 5px rgba(220, 53, 69, 0.5); }
      50% { box-shadow: 0 0 10px rgba(220, 53, 69, 0.8); }
      100% { box-shadow: 0 0 5px rgba(220, 53, 69, 0.5); }
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      width: 100%;
      max-width: 32rem;
    }
    button {
      padding: 0.625rem 1rem;
      font-size: 0.9375rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      flex: 1 1 auto;
    }
    button:hover:not(:disabled) { filter: brightness(90%); transform: scale(1.02); }
    button:focus { outline: 2px solid #007bff; }
    button.play { background: #007bff; color: #fff; }
    button.stop { background: #dc3545; color: #fff; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    button#randomBtn { background: #28a745; color: #fff; }
    button#themeToggle { background: #ffc107; color: #333; }
    button#playRecordingBtn { background: #17a2b8; color: #fff; }
    #feedback {
      margin-top: 1rem;
      padding: 0.625rem;
      max-width: 32rem;
      background: #fff;
      border-radius: 0.5rem;
      border: 1px solid #ddd;
      overflow-wrap: break-word;
      max-height: 20rem;
      overflow-y: auto;
      transition: background 0.3s, border-color 0.3s;
    }
    body.dark #feedback {
      background: #1e1e1e;
      border-color: #444;
    }
    #feedback h3 { margin: 0 0 0.5rem; }
    .correct {
      color: #28a745;
      font-weight: bold;
    }
    .incorrect {
      color: #dc3545;
      font-weight: bold;
      text-decoration: underline;
    }
    .gap {
      color: #aaa;
      font-style: italic;
    }
    #feedback ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    #progress {
      margin-top: 0.5rem;
      width: 100%;
      max-width: 32rem;
      height: 0.5rem;
      background: #ddd;
      border-radius: 0.25rem;
      overflow: hidden;
    }
    body.dark #progress { background: #444; }
    #progressBar {
      height: 100%;
      background: #007bff;
      width: 0;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <main>
    <h1>Pronunciation Practice</h1>
    <section>
      <textarea id="inputText" class="input" placeholder="Enter text (max 500 chars)" data-count="0/500"></textarea>
      <select id="voiceSelect" class="input"></select>
      <div class="button-group">
        <button id="playBtn" class="play" aria-label="Play text">üîä Listen</button>
        <button id="stopPlayBtn" class="stop" aria-label="Stop playing text" disabled>‚èπ Stop Listening</button>
        <button id="recordBtn" aria-label="Start recording">üéô Start Recording</button>
        <button id="stopRecordBtn" class="stop" aria-label="Stop recording" disabled>‚èπ Stop Recording</button>
        <button id="playRecordingBtn" aria-label="Play recording" disabled>‚ñ∂Ô∏è Play Recording</button>
        <button id="stopRecordingPlayBtn" class="stop" aria-label="Stop playing recording" disabled>‚èπ Stop Playback</button>
        <button id="randomBtn">üé≤ Random Sentence</button>
        <button id="themeToggle">üåô Dark Mode</button>
      </div>
    </section>
    <div id="progress"><div id="progressBar"></div></div>
    <section id="feedback" aria-live="polite">
      <h3>Feedback</h3>
      <p id="result">No feedback yet.</p>
    </section>
  </main>
  <script>
    (function () {
      // Debug toggle (set to true for detailed console logs)
      const DEBUG = false;

      // Centralized state management
      const state = {
        synth: window.speechSynthesis,
        voices: [],
        utterance: null,
        recognition: null,
        mediaRecorder: null,
        audioChunks: [],
        audioUrl: null,
        audio: null,
        isRecording: false,
        scores: [],
        micPermissionGranted: false,
        retryCount: 0,
      };

      // DOM elements
      const els = {
        inputText: document.getElementById("inputText"),
        voiceSelect: document.getElementById("voiceSelect"),
        playBtn: document.getElementById("playBtn"),
        stopPlayBtn: document.getElementById("stopPlayBtn"),
        recordBtn: document.getElementById("recordBtn"),
        stopRecordBtn: document.getElementById("stopRecordBtn"),
        playRecordingBtn: document.getElementById("playRecordingBtn"),
        stopRecordingPlayBtn: document.getElementById("stopRecordingPlayBtn"),
        randomBtn: document.getElementById("randomBtn"),
        themeToggle: document.getElementById("themeToggle"),
        result: document.getElementById("result"),
        progressBar: document.getElementById("progressBar"),
      };

      // Utility for error handling and logging
      const utils = {
        log(message, ...args) {
          if (DEBUG) console.log(`[PronunciationApp] ${message}`, ...args);
        },
        handleError(error, userMessage) {
          console.error(`[PronunciationApp] Error: ${error.message || error}`, error);
          alert(userMessage);
        },
        escapeHtml(unsafe) {
          return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        },
        normalizeText(text) {
          return text
            .normalize("NFKD")
            .toLowerCase()
            .replace(/[‚Äú‚Äù‚Äò‚Äô]/g, "'")
            .replace(/[^\w\s']/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        },
      };

      // Speech Synthesis module
      const speechSynth = {
        loadVoices() {
          utils.log("Loading voices...");
          state.voices = state.synth.getVoices();
          if (!state.voices.length) {
            utils.log("No voices loaded, retrying...");
            setTimeout(speechSynth.loadVoices, 100);
            return;
          }
          els.voiceSelect.innerHTML = '<option value="">Select Voice</option>';
          state.voices.forEach((v, i) => {
            const option = document.createElement("option");
            option.value = i;
            option.textContent = `${v.name}${v.lang ? ` (${v.lang})` : ""}`;
            els.voiceSelect.appendChild(option);
          });
          const lastVoice = localStorage.getItem("lastVoiceIndex");
          if (lastVoice !== null) {
            els.voiceSelect.value = lastVoice;
          }
          utils.log(`Loaded ${state.voices.length} voices`);
        },
        playText() {
          const text = els.inputText.value.trim();
          if (!text) {
            utils.handleError(new Error("Empty input"), "Please enter some text.");
            return;
          }
          if (text.length > 500) {
            utils.handleError(new Error("Text too long"), "Text too long. Limit 500 chars.");
            return;
          }
          state.synth.cancel();
          state.utterance = new SpeechSynthesisUtterance(text);
          const selectedIndex = els.voiceSelect.value;
          if (state.voices[selectedIndex]) {
            state.utterance.voice = state.voices[selectedIndex];
            localStorage.setItem("lastVoiceIndex", selectedIndex);
          } else {
            utils.log("No voice selected, using default");
          }
          state.utterance.onend = () => {
            utils.log("Playback finished");
            state.synth.cancel();
            ui.updateButtonStates();
          };
          state.synth.speak(state.utterance);
          ui.updateButtonStates();
          utils.log("Starting playback");
        },
        stopPlayback() {
          state.synth.cancel();
          ui.updateButtonStates();
          utils.log("Playback stopped");
        },
      };

      // Speech Recognition module
      const speechRecognition = {
        async checkMicPermission() {
          if (state.micPermissionGranted) return true;
          if (navigator.permissions && navigator.permissions.query) {
            try {
              const result = await navigator.permissions.query({ name: "microphone" });
              if (result.state === "granted") {
                state.micPermissionGranted = true;
                localStorage.setItem("micPermission", "granted");
                return await speechRecognition.requestMicPermission();
              } else if (result.state === "prompt") {
                return await speechRecognition.requestMicPermission();
              } else {
                state.micPermissionGranted = false;
                localStorage.removeItem("micPermission");
                utils.handleError(
                  new Error("Mic permission denied"),
                  "Microphone access is denied. Please enable it in your browser settings."
                );
                return false;
              }
            } catch (error) {
              utils.log("Permission query failed, attempting getUserMedia", error);
              return await speechRecognition.requestMicPermission();
            }
          } else {
            utils.log("navigator.permissions.query not supported, attempting getUserMedia");
            return await speechRecognition.requestMicPermission();
          }
        },
        async requestMicPermission() {
          const MAX_MIC_RETRIES = 2;
          let attempts = state.micRetryAttempts || 0;

          while (attempts < MAX_MIC_RETRIES) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              state.mediaRecorder = new MediaRecorder(stream);
              state.audioChunks = [];
              state.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) state.audioChunks.push(e.data);
              };
              state.mediaRecorder.onstop = () => {
                const blob = new Blob(state.audioChunks, { type: 'audio/webm' });
                state.audioUrl = URL.createObjectURL(blob);
                state.audio = new Audio(state.audioUrl);
                state.audioChunks = [];
                stream.getTracks().forEach(track => track.stop());
                ui.updateButtonStates();
                utils.log("Recording saved for playback");
              };
              state.micPermissionGranted = true;
              state.micRetryAttempts = 0;
              localStorage.setItem("micPermission", "granted");
              utils.log("Mic permission granted");
              return true;
            } catch (error) {
              attempts++;
              state.micRetryAttempts = attempts;
              utils.log(`Mic permission attempt ${attempts}/${MAX_MIC_RETRIES} failed`, error);
              if (attempts >= MAX_MIC_RETRIES) {
                state.micPermissionGranted = false;
                localStorage.removeItem("micPermission");
                let userMessage;
                if (error.name === "NotAllowedError") {
                  userMessage = "Microphone access denied. Please allow microphone access in your browser's site settings (e.g., Chrome: Settings > Privacy and security > Site settings > Microphone).";
                } else if (error.name === "NotFoundError") {
                  userMessage = "No microphone detected. Please connect a microphone and try again.";
                } else if (error.name === "SecurityError") {
                  userMessage = "Microphone access blocked due to browser security settings. Ensure this site is accessed over HTTPS and check your browser's microphone permissions.";
                } else {
                  userMessage = `Failed to access microphone: ${error.message}. Please ensure a microphone is connected and permissions are allowed in your browser settings.`;
                }
                utils.handleError(error, userMessage);
                return false;
              }
              await new Promise(resolve => setTimeout(resolve, 500)); // Brief delay before retry
            }
          }
          return false;
        },
        init() {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SpeechRecognition) {
            utils.handleError(
              new Error("SpeechRecognition not supported"),
              "SpeechRecognition not supported in this browser."
            );
            els.recordBtn.disabled = true;
            els.stopRecordBtn.disabled = true;
            els.playRecordingBtn.disabled = true;
            els.stopRecordingPlayBtn.disabled = true;
            return;
          }
          state.recognition = new SpeechRecognition();
          state.recognition.lang = "en-US";
          state.recognition.interimResults = true;
          state.recognition.continuous = true;
          state.recognition.maxAlternatives = 1;
          utils.log(`Using ${SpeechRecognition === window.SpeechRecognition ? "SpeechRecognition" : "webkitSpeechRecognition"}`);

          const SILENCE_THRESHOLD = 10000;
          const MAX_RETRIES = 3;
          let silenceTimeout;

          state.recognition.onresult = (event) => {
            clearTimeout(silenceTimeout);
            state.retryCount = 0;
            const transcript = event.results[event.results.length - 1][0].transcript;
            if (event.results[event.results.length - 1].isFinal) {
              feedback.generate(transcript);
              state.recognition.stop();
            } else {
              const interimDiv = document.createElement("div");
              interimDiv.appendChild(document.createTextNode("Interim: "));
              interimDiv.appendChild(document.createTextNode(transcript));
              els.result.innerHTML = '';
              els.result.appendChild(interimDiv);
            }
            silenceTimeout = setTimeout(() => {
              state.recognition.stop();
              utils.log("Stopped due to silence timeout");
            }, SILENCE_THRESHOLD);
            utils.log("Recognition result received", transcript);
          };

          state.recognition.onerror = (e) => {
            clearTimeout(silenceTimeout);
            if (e.error === "no-speech" && state.isRecording && state.retryCount < MAX_RETRIES) {
              state.retryCount++;
              const delay = Math.pow(2, state.retryCount) * 1000;
              utils.log(`No-speech error, retry ${state.retryCount}/${MAX_RETRIES} after ${delay}ms`);
              setTimeout(() => {
                if (state.isRecording) {
                  state.recognition.start();
                  utils.log("Retrying recognition");
                }
              }, delay);
            } else {
              const userMessage = e.error === "no-speech"
                ? "No speech detected after multiple attempts. Please try again."
                : `Speech recognition error: ${e.error}. Check your microphone or browser settings.`;
              utils.handleError(e, userMessage);
              state.isRecording = false;
              state.retryCount = 0;
              els.inputText.classList.remove("recording");
              ui.updateButtonStates();
            }
          };

          state.recognition.onend = () => {
            clearTimeout(silenceTimeout);
            if (state.isRecording && state.retryCount < MAX_RETRIES) {
              state.recognition.start();
              utils.log("Restarting recognition");
            } else {
              state.isRecording = false;
              state.retryCount = 0;
              if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
                state.mediaRecorder.stop();
              }
              els.inputText.classList.remove("recording");
              ui.updateButtonStates();
              utils.log("Recognition stopped");
            }
          };

          if (localStorage.getItem("micPermission") === "granted") {
            state.micPermissionGranted = true;
          }
        },
        async start() {
          if (!state.recognition || state.isRecording) return;
          if (!await speechRecognition.checkMicPermission()) {
            return;
          }
          state.isRecording = true;
          state.retryCount = 0;
          if (state.audioUrl) {
            URL.revokeObjectURL(state.audioUrl);
            state.audioUrl = null;
            state.audio = null;
          }
          els.inputText.classList.add("recording");
          state.recognition.start();
          if (state.mediaRecorder) {
            state.mediaRecorder.start();
            utils.log("MediaRecorder started");
          }
          ui.updateButtonStates();
          utils.log("Recording started");
        },
        stop() {
          if (state.isRecording) {
            state.isRecording = false;
            state.retryCount = 0;
            state.recognition.stop();
            if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
              state.mediaRecorder.stop();
            }
            ui.updateButtonStates();
            utils.log("Recording stopped manually");
          }
        },
        playRecording() {
          if (state.audio) {
            state.audio.play();
            ui.updateButtonStates();
            utils.log("Playing recording");
          }
        },
        stopRecordingPlayback() {
          if (state.audio && !state.audio.paused) {
            state.audio.pause();
            state.audio.currentTime = 0;
            ui.updateButtonStates();
            utils.log("Recording playback stopped");
          }
        },
      };

      // Feedback module
      const feedback = {
        generate(transcript) {
          const original = els.inputText.value.trim();
          if (!original) {
            utils.handleError(new Error("No input text"), "No text to compare.");
            return;
          }
          const spoken = transcript.trim();
          const originalNorm = utils.normalizeText(original);
          const spokenNorm = utils.normalizeText(spoken);
          const origWords = originalNorm.split(/\s+/);
          const spokenWords = spokenNorm.split(/\s+/);
          if (origWords.length > 50 || spokenWords.length > 50) {
            utils.handleError(new Error("Text too long"), "Text is too long for detailed feedback (max 50 words).");
            return;
          }
          const alignment = feedback.levenshteinAlignment(origWords, spokenWords);
          const similarity = feedback.calcSimilarity(alignment.distance, origWords.length, spokenWords.length);
          const { mismatchedWords, wordFeedback, errorTypes } = feedback.findMismatchedWordsFromAlignment(alignment.aAligned, alignment.bAligned);

          state.scores.push(similarity);
          if (state.scores.length > 5) state.scores.shift();
          const avgScore = state.scores.length > 1
            ? Math.round(state.scores.reduce((a, b) => a + b, 0) / state.scores.length)
            : similarity;

          let motivation = "";
          if (similarity >= 90) motivation = "Excellent! You're a pro. üåü";
          else if (similarity >= 70) motivation = "Good effort! Keep practicing. üëç";
          else motivation = "Room for improvement. Focus on sounds! üí™";

          const sttErrors = errorTypes.filter(e => e.type === "phoneme_confusion").map(e => e.word);
          let sttNote = "";
          if (sttErrors.length > 0) {
            sttNote = `Note: Some mismatches (e.g., ${sttErrors.slice(0, 3).map(w => utils.escapeHtml(w)).join(", ")}) may be due to transcription errors. Speak clearly or check your microphone.`;
          }

          const topErrors = feedback.prioritizeErrors(errorTypes);
          const feedbackDiv = document.createElement("div");
          feedbackDiv.appendChild(document.createTextNode(`Scores: Current ${similarity}% | Average (last ${Math.min(5, state.scores.length)}) ${avgScore}%`));
          feedbackDiv.appendChild(document.createTextNode(` (${motivation})`));
          feedbackDiv.appendChild(document.createElement("br"));
          feedbackDiv.appendChild(document.createTextNode("Transcript: "));
          feedbackDiv.appendChild(document.createTextNode(spoken));
          feedbackDiv.appendChild(document.createElement("br"));
          if (sttNote) {
            const noteDiv = document.createElement("div");
            noteDiv.textContent = sttNote;
            feedbackDiv.appendChild(noteDiv);
          }
          const origDiv = document.createElement("div");
          origDiv.appendChild(document.createTextNode("Original: "));
          origDiv.appendChild(feedback.createHighlightedSpan(alignment.aAligned, wordFeedback, true));
          feedbackDiv.appendChild(origDiv);
          const spokenDiv = document.createElement("div");
          spokenDiv.appendChild(document.createTextNode("You said: "));
          spokenDiv.appendChild(feedback.createHighlightedSpan(alignment.bAligned, wordFeedback, false));
          feedbackDiv.appendChild(spokenDiv);
          if (topErrors.length) {
            const tipsDiv = document.createElement("div");
            tipsDiv.appendChild(document.createTextNode("Top Fixes: "));
            const tipsList = document.createElement("ul");
            topErrors.forEach(e => {
              const li = document.createElement("li");
              li.textContent = `${utils.escapeHtml(e.word)}: ${e.tip}`;
              tipsList.appendChild(li);
            });
            tipsDiv.appendChild(tipsList);
            feedbackDiv.appendChild(tipsDiv);
            const practiceDiv = document.createElement("div");
            practiceDiv.appendChild(document.createTextNode(`Practice: Repeat "${topErrors.map(e => utils.escapeHtml(e.word)).slice(0, 3).join(", ")}" (slowly).`));
            feedbackDiv.appendChild(practiceDiv);
          } else {
            feedbackDiv.appendChild(document.createTextNode("Perfect match! üéâ"));
          }

          els.result.innerHTML = '';
          els.result.appendChild(feedbackDiv);
          ui.updateProgress(avgScore);
          utils.log("Feedback generated", { similarity, avgScore, topErrors });
        },
        levenshteinAlignment(aWords, bWords) {
          const aLen = aWords.length;
          const bLen = bWords.length;
          if (aLen > 50 || bLen > 50) return { aAligned: aWords, bAligned: bWords, distance: 0 };

          const costs = Array(aLen + 1).fill().map(() => Array(bLen + 1).fill(0));

          for (let j = 0; j <= bLen; j++) {
            costs[0][j] = j;
          }
          for (let i = 1; i <= aLen; i++) {
            costs[i][0] = i;
            for (let j = 1; j <= bLen; j++) {
              costs[i][j] = Math.min(
                1 + Math.min(costs[i - 1][j], costs[i][j - 1]),
                aWords[i - 1] === bWords[j - 1] ? costs[i - 1][j - 1] : costs[i - 1][j - 1] + 1
              );
            }
          }

          let aPathRev = [];
          let bPathRev = [];
          let i = aLen, j = bLen;
          while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && costs[i][j] === (aWords[i - 1] === bWords[j - 1] ? costs[i - 1][j - 1] : costs[i - 1][j - 1] + 1)) {
              aPathRev.push(aWords[i - 1]);
              bPathRev.push(bWords[j - 1]);
              i--;
              j--;
            } else if (i > 0 && costs[i][j] === 1 + costs[i - 1][j]) {
              aPathRev.push(aWords[i - 1]);
              bPathRev.push('-');
              i--;
            } else if (j > 0 && costs[i][j] === 1 + costs[i][j - 1]) {
              aPathRev.push('-');
              bPathRev.push(bWords[j - 1]);
              j--;
            }
          }

          return {
            aAligned: aPathRev.reverse(),
            bAligned: bPathRev.reverse(),
            distance: costs[aLen][bLen]
          };
        },
        calcSimilarity(distance, aLen, bLen) {
          if (Math.max(aLen, bLen) === 0) return 100;
          return Math.round((1 - distance / Math.max(aLen, bLen)) * 100);
        },
        findMismatchedWordsFromAlignment(aAligned, bAligned) {
          const mismatchedWords = [];
          const wordFeedback = [];
          const errorTypes = [];
          const fillers = new Set(['uh', 'um', 'ah', 'er', 'hmm']);
          const vowels = /(ee|ea|oo|ie|oa|ai|ou|au)/i;

          const maxLen = Math.max(aAligned.length, bAligned.length);
          for (let k = 0; k < maxLen; k++) {
            const word = aAligned[k] || '';
            const spokenWord = bAligned[k] || '';
            if (fillers.has(spokenWord)) {
              aAligned[k] = '';
              bAligned[k] = '';
              continue;
            }

            let errorType = null;
            let tip = null;

            if (word === '-') {
              errorType = "insertion";
              tip = "Avoid extra words.";
            } else if (spokenWord === '-') {
              errorType = "missing";
              tip = "Ensure all words are spoken.";
            } else if (word === spokenWord) {
              errorType = "correct";
            } else {
              errorType = "substitution";
              if (feedback.soundex(word) === feedback.soundex(spokenWord) || feedback.editDistance(word, spokenWord) <= 2) {
                errorType = "phoneme_confusion";
                tip = feedback.getPronunciationTips(word, spokenWord);
              } else if (word.startsWith(spokenWord) && word.length === spokenWord.length + 1 && /[bcdfghjklmnpqrstvwxyz]$/.test(word)) {
                errorType = "final_consonant_drop";
                tip = "Pronounce final consonant clearly.";
              } else if (vowels.test(word) && !vowels.test(spokenWord)) {
                errorType = "vowel_length";
                tip = "Focus on vowel length (e.g., 'seat' vs 'set').";
              } else {
                tip = "Check pronunciation of each sound.";
              }
              mismatchedWords.push(word);
            }

            wordFeedback.push({ word, spokenWord, isCorrect: errorType === "correct" });
            errorTypes.push({ word, spokenWord, type: errorType, tip });
          }
          return { mismatchedWords, wordFeedback, errorTypes };
        },
        prioritizeErrors(errorTypes) {
          const errorCounts = {};
          errorTypes.forEach(e => {
            if (e.type !== "correct") {
              errorCounts[e.type] = (errorCounts[e.type] || 0) + 1;
            }
          });

          const priority = [
            "phoneme_confusion",
            "final_consonant_drop",
            "vowel_length",
            "substitution",
            "insertion",
            "missing"
          ];

          return errorTypes
            .filter(e => e.type !== "correct" && e.tip)
            .sort((a, b) => {
              const aPriority = priority.indexOf(a.type);
              const bPriority = priority.indexOf(b.type);
              if (aPriority !== bPriority) return aPriority - bPriority;
              return (errorCounts[b.type] || 0) - (errorCounts[a.type] || 0);
            })
            .slice(0, 3);
        },
        createHighlightedSpan(alignedWords, wordFeedback, isOriginal) {
          const span = document.createElement("span");
          alignedWords.forEach((word, i) => {
            if (i > 0) span.appendChild(document.createTextNode(" "));
            if (word === '-') {
              const gapSpan = document.createElement("span");
              gapSpan.className = "gap";
              gapSpan.textContent = "[gap]";
              span.appendChild(gapSpan);
              return;
            }
            const feedback = wordFeedback[i];
            if (!feedback) {
              span.appendChild(document.createTextNode(word));
              return;
            }
            const wordSpan = document.createElement("span");
            wordSpan.className = feedback.isCorrect ? "correct" : "incorrect";
            wordSpan.textContent = word;
            span.appendChild(wordSpan);
          });
          return span;
        },
        getPronunciationTips(original, spoken) {
          const tips = {
            th: "Place tongue between teeth for 'th'.",
            r: "Curl tongue for 'r'.",
            l: "Touch tongue to roof for 'l'.",
            v: "Teeth on lip for 'v'.",
            w: "Round lips for 'w'.",
          };
          if ((original.includes("th") && spoken.includes("t")) || (original.includes("th") && spoken.includes("d"))) {
            return tips.th;
          } else if ((original.includes("r") && spoken.includes("l")) || (original.includes("l") && spoken.includes("r"))) {
            return `${tips.r} or ${tips.l}`;
          } else if ((original.includes("v") && spoken.includes("b")) || (original.includes("w") && spoken.includes("v"))) {
            return `${tips.v} or ${tips.w}`;
          } else {
            return "Focus on each sound.";
          }
        },
        soundex(word) {
          if (!word) return '';
          word = word.toUpperCase();
          let code = word[0];
          const map = { B:1, F:1, P:1, V:1, C:2, G:2, J:2, K:2, Q:2, S:2, X:2, Z:2, D:3, T:3, L:4, M:5, N:5, R:6 };
          let prevNum = null;
          for (let i = 1; i < word.length; i++) {
            const char = word[i];
            const num = map[char];
            if (num !== undefined && num !== prevNum) {
              code += num;
            }
            prevNum = num;
          }
          code = code.replace(/[AEIOUYHW]/g, '');
          code = code.replace(/(.)\1+/g, '$1');
          return (code + '000').substring(0, 4);
        },
        editDistance(s1, s2) {
          const dp = Array(s2.length + 1).fill().map(() => Array(s1.length + 1).fill(0));
          for (let i = 0; i <= s1.length; i++) dp[0][i] = i;
          for (let j = 0; j <= s2.length; j++) dp[j][0] = j;
          for (let j = 1; j <= s2.length; j++) {
            for (let i = 1; i <= s1.length; i++) {
              dp[j][i] = s1[i - 1] === s2[j - 1] ? dp[j - 1][i - 1] : Math.min(dp[j - 1][i - 1], dp[j - 1][i], dp[j][i - 1]) + 1;
            }
          }
          return dp[s2.length][s1.length];
        },
      };

      // UI module
      const ui = {
        updateButtonStates() {
          els.playBtn.disabled = state.synth.speaking || state.isRecording;
          els.stopPlayBtn.disabled = !state.synth.speaking;
          els.recordBtn.disabled = state.isRecording || state.synth.speaking || !state.micPermissionGranted;
          els.stopRecordBtn.disabled = !state.isRecording;
          els.playRecordingBtn.disabled = !state.audioUrl || state.isRecording || (state.audio && !state.audio.paused);
          els.stopRecordingPlayBtn.disabled = !state.audio || state.audio.paused;
          utils.log("Button states updated", {
            playBtn: !els.playBtn.disabled,
            stopPlayBtn: !els.stopPlayBtn.disabled,
            recordBtn: !els.recordBtn.disabled,
            stopRecordBtn: !els.stopRecordBtn.disabled,
            playRecordingBtn: !els.playRecordingBtn.disabled,
            stopRecordingPlayBtn: !els.stopRecordingPlayBtn.disabled,
          });
        },
        updateCharCount() {
          const count = els.inputText.value.length;
          els.inputText.setAttribute("data-count", `${count}/500`);
        },
        updateProgress(avgScore) {
          els.progressBar.style.width = `${avgScore}%`;
        },
        toggleTheme() {
          document.body.classList.toggle("dark");
          const isDark = document.body.classList.contains("dark");
          els.themeToggle.textContent = isDark ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
          localStorage.setItem("theme", isDark ? "dark" : "light");
        },
        loadRandomSentence() {
          const sentences = [
            "The quick brown fox jumps over the lazy dog.",
            "Practice makes perfect.",
            "She sells sea shells by the sea shore.",
            "How much wood would a woodchuck chuck if a woodchuck could chuck wood?",
            "Peter Piper picked a peck of pickled peppers.",
          ];
          const random = sentences[Math.floor(Math.random() * sentences.length)];
          els.inputText.value = random;
          ui.updateCharCount();
        },
      };

      // Initialize event listeners
      function init() {
        speechSynth.loadVoices();
        state.synth.onvoiceschanged = speechSynth.loadVoices;
        speechRecognition.init();

        els.playBtn.onclick = speechSynth.playText;
        els.stopPlayBtn.onclick = speechSynth.stopPlayback;
        els.recordBtn.onclick = speechRecognition.start;
        els.stopRecordBtn.onclick = speechRecognition.stop;
        els.playRecordingBtn.onclick = speechRecognition.playRecording;
        els.stopRecordingPlayBtn.onclick = speechRecognition.stopRecordingPlayback;
        els.inputText.addEventListener("input", ui.updateCharCount);
        els.randomBtn.onclick = ui.loadRandomSentence;
        els.themeToggle.onclick = ui.toggleTheme;

        if (localStorage.getItem("theme") === "dark") {
          ui.toggleTheme();
        }

        ui.updateButtonStates();
        utils.log("App initialized");
      }

      // Start the app
      init();
    })();
  </script>
</body>
</html>
